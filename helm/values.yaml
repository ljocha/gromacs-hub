debug:
  enabled: true

proxy:
  service:
    type: ClusterIP
  chp:
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 1
        memory: 256Mi

rbac:
  create: false

ingress:
  enabled: true
 #ingressClassName: nginx
  annotations:
    kubernetes.io/tls-acme: "true"
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/proxy-body-size: 300m
  hosts:
#    - hub-aicope.cloud.trusted.e-infra.cz
    - gromacs-hub.dyn.cloud.e-infra.cz
  tls:
    - hosts:
        - gromacs-hub.dyn.cloud.e-infra.cz
      secretName: "gromacs-hub-dyn-cloud-e-infra-cz-tls"

hub:
  serviceAccount:
    create: false
    name: default

  #allowNamedServers: true
  containerSecurityContext:
    allowPrivilegeEscalation: false
    capabilities:
     drop:
     - ALL
  podSecurityContext:
    fsGroupChangePolicy: OnRootMismatch
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault
  extraConfig:
    form-0: |
        from traitlets import default, Unicode
        from tornado import gen
        from kubespawner import KubeSpawner

        class SillySpawner(KubeSpawner):
          form_template = Unicode("""
          <h3>Home</h3>
          <div id="phomeDiv" style="display: block;">
          <input type="checkbox" id="delhome" name="delhome" value="delete">
          <label for="delhome">Erase if home exists</label><br/>
          <p style="background-color:orange;">Take care of checking this button, it removes whole home directory and previous data will be lost. Use in case only when notebook is broken so it does not start, in other cases, remove data from terminal.</p>
          </div>
          """,)

          option_template = Unicode("""
              <option value="{item}">{item}</option>""",
              config = True, help = "Template for html form options."
          )

            
          async def get_options_form(self):
            return self.form_template
                                                                                
    form-1: |
      c.JupyterHub.spawner_class = SillySpawner
      c.MappingKernelManager.cull_idle_timeout = 259200
      c.MappingKernelManager.cull_connected = False
      c.MappingKernelManager.cull_busy = False
      c.NotebookApp.shutdown_no_activity_timeout = 259200

    pre-spawn-hook: |
      import asyncio
      import kubernetes_asyncio
      from kubernetes_asyncio import config, client

      from kubernetes_asyncio.client import (
          V1ObjectMeta,
          V1Secret,
          V1PersistentVolume,
          V1PersistentVolumeClaim,
          V1ResourceRequirements,
          V1LabelSelector,
          V1CSIPersistentVolumeSource,
          V1PersistentVolumeSpec,
          V1PersistentVolumeClaimSpec,
          V1Namespace,
          V1ServiceAccount,
          V1RoleBinding,
          V1RoleRef,
          V1Subject,
          V1ClusterRole,
          V1PolicyRule,
          ApiException,
      )

      async def check_pvc(home_pvc_name, namespace):
          async with kubernetes_asyncio.client.ApiClient() as api_client:
              v1 = kubernetes_asyncio.client.CoreV1Api(api_client)
              pvcs = await v1.list_namespaced_persistent_volume_claim(namespace)
              for claim in pvcs.items:
                  if claim.metadata.name == home_pvc_name:
                      return claim
              return None

      async def delete_pvc(namespace, pvc):
          async with kubernetes_asyncio.client.ApiClient() as api_client:
              v1 = kubernetes_asyncio.client.CoreV1Api(api_client)
              await v1.delete_namespaced_persistent_volume_claim(name=pvc, namespace=namespace)
              await asyncio.sleep(1)

      async def create_pvc(home_pvc_name, home_pv_name, namespace, storage_class, capacity):
          pvc = V1PersistentVolumeClaim()
          pvc.api_version = "v1"
          pvc.kind = "PersistentVolumeClaim"
          pvc.metadata = V1ObjectMeta()
          pvc.metadata.name = home_pvc_name
          pvc.spec = V1PersistentVolumeClaimSpec()
          pvc.spec.access_modes = ['ReadWriteMany']
          pvc.spec.resources = V1ResourceRequirements()
          pvc.spec.resources.requests = {"storage": capacity}
          pvc.spec.storage_class_name = storage_class
          if storage_class != "nfs-csi":
              pvc.spec.selector = V1LabelSelector()
              pvc.spec.selector.match_labels = {"name": home_pv_name}
          try:
            async with kubernetes_asyncio.client.ApiClient() as api_client:
              v1 = kubernetes_asyncio.client.CoreV1Api(api_client)
              x = await v1.create_namespaced_persistent_volume_claim(namespace, pvc)
              await asyncio.sleep(1)
          except ApiException as e:
            if re.search("object is being deleted:", e.body):
              raise web.HTTPError(401, "Can't delete PVC {}, please contact administrator!".format(home_pvc_name))
              return False
          return True

      def add_volume(spawner_vol_list, volume, volname):
          volume_exists = False
          for vol in spawner_vol_list:
              if "name" in vol and vol["name"] == volname:
                  volume_exists = True
          if not volume_exists:
              spawner_vol_list.append(volume) 

      def mount(spawner, pv, pvc, mountpath):
          volume = {"name": pv, "persistentVolumeClaim": {"claimName": pvc}}
          volume_mount = {"mountPath": mountpath, "name": pv}
          if len(spawner.volumes) == 0:
              spawner.volumes = [volume]
          else:
              add_volume(spawner.volumes, volume, pv)
          if len(spawner.volume_mounts) == 0:
              spawner.volume_mounts = [volume_mount]
          else:
              add_volume(spawner.volume_mounts, volume_mount, pvc)

      async def mount_persistent_hub_home(spawner, username, namespace):
          hub_home_name = username + "-home-default"

          if spawner.user_options.get('delhome') == "delete":
              pvc = await check_pvc(hub_home_name, namespace)
              if pvc:
                await delete_pvc(namespace, hub_home_name)
              await create_pvc(hub_home_name, hub_home_name + "-pv", namespace, "nfs-csi", "10Gi")
          else:
            pvc = await check_pvc(hub_home_name, namespace)
            if not pvc:
              await create_pvc(hub_home_name, hub_home_name + "-pv", namespace, "nfs-csi", "10Gi")

          mount(spawner, hub_home_name + "-pv", hub_home_name, "/home/jovyan")
       

      async def bootstrap_pre_spawn(spawner):
        config.load_incluster_config()
        namespace = spawner.namespace
        username = spawner.user.name
        original = username
        if "-" in username:
            username = username.replace("-", "-2d")
        if "_" in username:
            username = username.replace("_", "-5f")

        spawner.environment = {"JUPYTERHUB_API_URL": "http://hub.krenek-ns.svc.cluster.local:8081/hub/api",
                               "JUPYTERHUB_ACTIVITY_URL": "http://hub.krenek-ns.svc.cluster.local:8081/hub/api/users/"+username+"/activity"}

        await mount_persistent_hub_home(spawner, username, namespace)

        if "--SingleUserNotebookApp.max_body_size=6291456000" not in spawner.args:
                spawner.args.append("--SingleUserNotebookApp.max_body_size=6291456000")

        gpu = spawner.user_options.get('gpu')
        cpu = spawner.user_options.get('cpu')
        mem = spawner.user_options.get('mem')
        image = spawner.user_options.get('container_image')

        spawner.image = 'ljocha/gromacs-hub'
        spawner.cpu_limit = 1.
        spawner.cpu_guarantee = .2
        spawner.mem_limit = '8G'
        spawner.mem_guarantee = '4G'

      c.KubeSpawner.pre_spawn_hook = bootstrap_pre_spawn
      c.KubeSpawner.enable_user_namespaces = False
  config:
#    Authenticator:
#      allowed_users:
#        - ljocha
#    DummyAuthenticator:
#      password: budul9nek
#      auto_login: true
#      enable_auth_state: true
    GenericOAuthenticator:
      authorize_url: https://login.e-infra.cz/oidc/authorize
      token_url: https://login.e-infra.cz/oidc/token
      userdata_url: https://login.e-infra.cz/oidc/userinfo
      oauth_callback_url: https://gromacs-hub.dyn.cloud.e-infra.cz/hub/oauth_callback

#      authorize_url: https://login.cloud.e-infra.cz/auth
#      token_url: https://login.cloud.e-infra.cz/token
#      userdata_url: https://login.cloud.e-infra.cz/userinfo
#      oauth_callback_url: https://gromacs-hub.dyn.cloud.e-infra.cz/hub/oauth_callback
      client_id: f408e904-6eb7-4398-b9b6-26c97c5c3295
      client_secret: a6cd66e9-30ff-4ab8-8643-af1b0df51a8f810d5def-43ec-4920-b21d-db21e1584dcf
      userdata_params:
        state: state
      scope:
        - openid
        - profile
        - email
      username_key: preferred_username
    JupyterHub:
      authenticator_class: generic-oauth
#      authenticator_class: dummy
  image:
    name: cerit.io/hubs/jupyterhub
    tag: 14-12-2022
  resources:
    requests:
      cpu: 100m
      memory: 256Mi
    limits:
      cpu: 1
      memory: 512Mi
  livenessProbe:
    initialDelaySeconds: 10
    periodSeconds: 10
    failureThreshold: 10
    timeoutSeconds: 10
  readinessProbe:
    initialDelaySeconds: 10
    periodSeconds: 10
    failureThreshold: 10
    timeoutSeconds: 10
#  extraEnv:
#    OAUTH2_AUTHORIZE_URL: https://login.cloud.e-infra.cz/auth
#    OAUTH2_TOKEN_URL: https://login.cloud.e-infra.cz/token 
#    OAUTH2_CALLBACK_URL: https://gromacs-hub.dyn.cloud.e-infra.cz/hub/oauth_callback
  db:
    pvc:
      storageClassName: nfs-csi
  containerSecurityContext:
    runAsUser: 1000
    runAsGroup: 1000
    allowPrivilegeEscalation: false
  consecutiveFailureLimit: 0
  networkPolicy:
    interNamespaceAccessLabels: "accept"
    egressAllowRules:
      cloudMetadataServer: false

singleuser:
  networkPolicy:
    enabled: false
  cloudMetadata:
    blockWithIptables: false                                                                     
  startTimeout: 600
  defaultUrl: "/lab"
  storage:  
    type: "none"
  cmd: jupyterhub-singleuser 
  uid: 1000
  fsGid: 100
  allowPrivilegeEscalation: false
  extraPodConfig:
    securityContext:
      fsGroupChangePolicy: OnRootMismatch
      runAsNonRoot: true
      seccompProfile:
        type: RuntimeDefault
      capabilities:
        drop:
        - ALL
  startTimeout: 300
  networkPolicy:
    enabled: false
  cloudMetadata:
    blockWithIptables: false
  

scheduling:
  userScheduler:
    enabled: false

prePuller:
  hook:
    enabled: false
  continuous:
    enabled: false

# singleuser MappingKernel https://jupyter-notebook.readthedocs.io/en/stable/config.html
# jupyterhub-idle-culler https://github.com/jupyterhub/zero-to-jupyterhub-k8s/blob/main/jupyterhub/values.yaml
cull:
  enabled: true
  users: true
  timeout: 259200
  every: 3600
